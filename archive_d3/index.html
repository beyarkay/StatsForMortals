<!DOCTYPE html>
<html lang="">
<head>
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans, serif;
            padding: 10px;
        }

        svg path {
            stroke: #000;
            stroke-width: 1px;
            stroke: rgba(0, 0, 0, 0.2);
        }

        svg {
            border: 1px solid #DED8BF;
            background-color: #f4f4d9;
            width: 700px;
            height: 400px;
        }

        h1 {
            font-weight: normal;
            margin: 0;
            padding-left: 5px;
            color: #53483e;
        }

        p {
            margin: 0;
            margin-bottom: 10px;
            padding-left: 5px;
            color: #917e6b;
        }

        ul {
            width: 200px;
            float: left;
            list-style-type: none;
            margin: 0;
            padding: 0;
            padding-right: 10px;
        }

        li {
            cursor: pointer;
            background-color: #c8ad93;
            padding: 10px;
            margin: 2px;
            color: #fff;
        }
    </style>
    <title>Statistics for Mortals</title>
</head>
<body>
<h1>Statistics for Mortals</h1>
<p>It's interactive! Drag to change</p>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="surface3d.js"></script>
<script>
    /*
    TODO: Maybe add in some fog to exaggerate the distance?
    TODO: Add axes
     */
    let yaw = 0.5;      // The orientation of the scaleToSurface
    let pitch = 0.5;    // The orientation of the scaleToSurface
    const width = 700;
    const height = 400;
    let being_dragged = false;
    let mu = [0.0, 0.0];
    let sigma = [0.5, 0.5];
    let rho = 0.0;
    const x_extent = [-3, 3];
    const y_extent = [-3, 3];

    function dataFromFormula(func) {
        // func: R^2 -> R, convert xy coordinates to a z value
        // Note that the resulting plot
        // is squished into a square domain,
        // regardless of the values of x_extent, or y_extent

        const sampling_freq = 0.1;
        const output = [];
        for (let x = x_extent[0]; x <= x_extent[1]; x += sampling_freq) {
            const f0 = [];
            output.push(f0);
            for (let y = y_extent[0]; y <= y_extent[1]; y += sampling_freq) {
                f0.push(func(x, y));
            }
        }
        return output;
    }

    /**
     * @return {number}
     */
    function BVN(x, y) {

        // make sure |rho| < 0.9999, so that it's a R.V.
        rho = Math.min(0.9999, Math.max(-0.9999, rho));
        const Q =
            Math.pow((x - mu[0]) / sigma[0], 2)
            - 2 * rho * ((x - mu[0]) / sigma[0]) * ((y - mu[1]) / sigma[1])
            + Math.pow((y - mu[1]) / sigma[1], 2);

        const quotient = 2 * Math.PI * Math.sqrt(1 - rho * rho) * Math.sqrt(sigma[0]) * Math.sqrt(sigma[1])

        let val = 1 / quotient * Math.exp(-Q / (2 * (1 - rho * rho)));
        return (val * -500);

    }


    let surfaces = [
        {
            name: 'Bivariate Normal',
            data: dataFromFormula(BVN)
        },
        // {
        //     name: 'sin(sqrt(xScale^2 + yScale^2))',
        //     traces: dataFromFormula(function (xScale, yScale) {
        //         return Math.sin(Math.sqrt(xScale * xScale + yScale * yScale) / 5 * Math.PI) * 50;
        //     })
        // },
        // {
        //     name: 'Dataset 2',
        //     traces: dataFromFormula(function (xScale, yScale) {
        //         return Math.cos(xScale / 15 * Math.PI) * Math.cos(yScale / 15 * Math.PI) * 60 + Math.cos(xScale / 8 * Math.PI) * Math.cos(yScale / 10 * Math.PI) * 40;
        //     })
        // },
        // {
        //     name: 'Dataset 3',
        //     traces: dataFromFormula(function (xScale, yScale) {
        //         return -(Math.cos(Math.sqrt(xScale * xScale + yScale * yScale) / 6 * Math.PI) + 1) * 300 / (Math.pow(xScale * xScale + yScale * yScale + 1, 0.3) + 1) + 50;
        //     })
        // }
    ];
    // const selected = surfaces[0];

    // Dataset Chooser
    const ul = d3.select('body')
        .append('ul');

    const svg = d3.select('body')
        .append('svg')
        .attr('height', height)
        .attr('width', width);

    const group = svg.append("g");

    const md = group.data([surfaces[0].data])
        .surface3D(width, height)
        .surfaceHeight(function (d) {
            return d;
        }).surfaceColor(function (d) {
            const c = d3.hsl((d + 100), 0.6, 0.5).rgb();
            return "rgb(" + parseInt(c.depth) + "," + parseInt(c.g) + "," + parseInt(c.b) + ")";
        });

    function update_surface() {
        surfaces[0].data = dataFromFormula(BVN);
        md.data([surfaces[0].data])
            .surface3D()
            // .transition().duration(5000)
            .surfaceHeight(function (d) {
                return d;
            }).surfaceColor(function (d) {
            const c = d3.hsl((d + 100), 0.6, 0.5).rgb();
            return "rgb(" + parseInt(c.depth) + "," + parseInt(c.g) + "," + parseInt(c.b) + ")";
        });
    }

    // Generic Slider
    const sliders = [
        {
            'id': 'rho',
            'label': 'rho',
            'value': 0,
            'min': -0.99,
            'max': 0.99,
            'step': 0.05,
            'on_input': function input() {
                rho = document.getElementById(this.id).value;
                update_surface();
            }
        },
        {
            'id': 'sigma_x2',
            'label': 'sigma_x2',
            'value': 1,
            'min': 0.1,
            'max': 5,
            'step': 0.1,
            'on_input': function input() {
                sigma[0] = document.getElementById(this.id).value;
                update_surface();
            }
        },
        {
            'id': 'sigma_y2',
            'label': 'sigma_y2',
            'value': 1,
            'min': 0.1,
            'max': 5,
            'step': 0.1,
            'on_input': function input() {
                sigma[1] = document.getElementById(this.id).value;
                update_surface();
            }
        },
        {
            'id': 'mu_x',
            'label': 'mu_x',
            'value': 0,
            'min': x_extent[0],
            'max': x_extent[1],
            'step': (y_extent[1] - y_extent[0]) / 20,
            'on_input': function input() {
                mu[0] = document.getElementById(this.id).value;
                update_surface();
            }
        },
        {
            'id': 'mu_y',
            'label': 'mu_y',
            'value': 0,
            'min': y_extent[0],
            'max': y_extent[1],
            'step': (y_extent[1] - y_extent[0]) / 20,
            'on_input': function input() {
                mu[1] = document.getElementById(this.id).value;
                update_surface();
            }
        }
    ];

    for (let i = 0; i < sliders.length; i++) {
        d3.select('body')
            .append("input")
            .attr("type", "range")
            .attr("value", sliders[i].value)
            .attr("min", sliders[i].min)
            .attr("max", sliders[i].max)
            .attr("step", sliders[i].step)
            .attr("id", sliders[i].id)
            .on("input", sliders[i].on_input);
        d3.select('body')
            .append('label')
            .html(sliders[i].label + "<br>");
    }


    ul.selectAll('li')
        .data(surfaces)
        .enter().append('li')
        .html(function (d) {
            return d.name
        }).on('mousedown',
        function () {
            md.data([d3.select(this).datum().data]).surface3D()
                .transition().duration(500)
                .surfaceHeight(function (d) {
                    return d;
                }).surfaceColor(function (d) {
                const c = d3.hsl((d + 100), 0.6, 0.5).rgb();
                return "rgb(" + parseInt(c.depth) + "," + parseInt(c.g) + "," + parseInt(c.b) + ")";
            });
        });

    svg.on("mousedown", function () {
        being_dragged = [d3.mouse(this), yaw, pitch];
        const mouse = d3.mouse(this);
        yaw = being_dragged[1] - (mouse[0] - being_dragged[0][0]) / 50;
        pitch = being_dragged[2] + (mouse[1] - being_dragged[0][1]) / 50;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        md.turntable(yaw, pitch);
    }).on("mouseup", function () {
        being_dragged = false;
    }).on("mousemove", function () {
        if (being_dragged) {
            const mouse = d3.mouse(this);
            yaw = being_dragged[1] - (mouse[0] - being_dragged[0][0]) / 50;
            pitch = being_dragged[2] + (mouse[1] - being_dragged[0][1]) / 50;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            md.turntable(yaw, pitch);
        }
    });
</script>
</body>
</html>