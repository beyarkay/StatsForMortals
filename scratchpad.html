<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <title>Scratchpad</title>
    <!--    <script src="http_d3js.org_d3.v5.js"></script>-->
    <!--    <script src="http_d3js.org_d3-scale-chromatic.v1.js"></script>-->
    <!--    <script src="http_unpkg.com_mathjs_dist_math.js"></script>-->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <!--    <script src="https://unpkg.com/d3-3d/build/d3-3d.min.js"></script>-->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://unpkg.com/mathjs/dist/math.min.js"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        //     </script>
    <!---->
    <link rel="stylesheet"
          href="https://unpkg.com/purecss@2.0.3/build/pure-min.css"
          integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ"
          crossorigin="anonymous">
    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">
    <link rel="stylesheet" href="styles.css">

    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div id="three_d_vibes"></div>

<script>
    // TODO limit rotation so the model can't be turned completely upsidedown, thereby inverting the drag controls
    // TODO every point / line / polygon / text object must:
    //      * have a depth
    //      * be thereafter sorted depth-wise, in order to make sure objects appear in front of each other properly
    // TODO Allow sliders to update the graph
    // TODO encapsulate the whole thing in a method
    // TODO change the sensitivity if the device is mobile / depending on the screen width

    const margin = {
        top: 10,
        right: 10,
        bottom: 30,
        left: 10,
    };
    const padding = {
        left: 40,
        right: 40
    };
    const width = (window.innerWidth - padding.left - padding.right - margin.left - margin.right);
    const height = width;
    let start = -2;
    let stop = -start;
    let step = 0.2;
    let scale = 0.5;
    let sensitivity = [0.002, 0.002];
    let rotation = [-Math.PI * 3 / 8, -Math.PI * 3 / 8, 0];
    const draw_paths = false;
    let id = 'three_d_vibes';
    let svg = d3.select('#' + id)
        .append('svg')
        .attr("viewBox", [0, 0, width, height]);


    // ----------========== Build up the point cloud ==========----------
    let points = [];

    function f(x, y) {
        // return math.exp(-0.5 * (x * x + y * y));
        return math.exp(Math.sin(x * x + y * y));
    }

    for (let x = start; x <= stop; x += step) {
        for (let y = start; y <= stop; y += step) {
            points.push([x, y, f(x, y)]);
        }
    }

    // ----------========== Build up the bounding box ==========----------
    let extents = [[
        Math.floor(d3.min(points, (d) => d[0])),
        Math.ceil(d3.max(points, (d) => d[0]))
    ], [
        Math.floor(d3.min(points, (d) => d[1])),
        Math.ceil(d3.max(points, (d) => d[1]))
    ], [
        Math.floor(d3.min(points, (d) => d[2])),
        Math.ceil(d3.max(points, (d) => d[2]))
    ]];

    // top or bottom surface
    let bottom = [
        [extents[0][0], extents[1][0], extents[2][0]],
        [extents[0][0], extents[1][1], extents[2][0]],
        [extents[0][1], extents[1][1], extents[2][0]],
        [extents[0][1], extents[1][0], extents[2][0]],
        [extents[0][0], extents[1][0], extents[2][0]],
    ];
    // left_or_right surface
    let right = [
        [extents[0][1], extents[1][0], extents[2][0]],
        [extents[0][1], extents[1][1], extents[2][0]],
        [extents[0][1], extents[1][1], extents[2][1]],
        [extents[0][1], extents[1][0], extents[2][1]],
        [extents[0][1], extents[1][0], extents[2][0]],
    ];
    // front_or_back surface
    let back = [
        [extents[0][0], extents[1][0], extents[2][0]],
        [extents[0][1], extents[1][0], extents[2][0]],
        [extents[0][1], extents[1][0], extents[2][1]],
        [extents[0][0], extents[1][0], extents[2][1]],
        [extents[0][0], extents[1][0], extents[2][0]],
    ];
    let polygons = [bottom, right, back];

    // ----------========== Define rotation & projection matrices ==========----------
    function rotX(theta) {
        return math.transpose([
            [1, 0, 0],
            [0, math.cos(theta), -math.sin(theta)],
            [0, math.sin(theta), math.cos(theta)]
        ]);
    }

    function rotY(theta) {
        return math.transpose([
            [math.cos(theta), 0, -math.sin(theta)],
            [0, 1, 0],
            [math.sin(theta), 0, math.cos(theta)]
        ]);
    }

    function rotZ(theta) {
        return math.transpose([
            [math.cos(theta), -math.sin(theta), 0],
            [math.sin(theta), math.cos(theta), 0],
            [0, 0, 1],
        ]);
    }

    const projection = math.transpose([
        [scale, 0, 0],
        [0, scale, 0],
        [0, 0, scale],
    ]);

    // ----------========== Create the Scales, line generator,  ==========----------
    // Create an x-num_points for xy to pixel coordinates
    xScale = d3.scaleLinear()
        .domain([start, stop])
        .range([margin.left, width - margin.right]);

    // Create a y-num_points for xy to pixel coordinates
    yScale = d3.scaleLinear()
        .domain([start, stop])
        .range([height - margin.bottom, margin.top]);

    lineGen = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y));

    // ----------========== Set up the SVG groups ==========----------


    svg.append('g').attr('class', 'lines');
    svg.append('g').attr('class', 'points');
    svg.append('g').attr('class', 'scale');


    // ----------========== Make the SVG draggable ==========----------
    let mouseStart;
    let mouseDelta;
    svg.call(d3.drag()
        .on("start", dragStarted)
        .on("drag", dragInProgress)
        .on("end", dragEnded)
    );

    function dragStarted(d) {
        d3.select(this).attr("fill", "black");
        mouseStart = [d3.event.x, d3.event.y];
    }

    function dragInProgress(d) {
        d3.select(this).attr("fill", "grey");
        mouseDelta = [d3.event.x - mouseStart[0], d3.event.y - mouseStart[1]];
        updatePlot(svg, [
            rotation[0] + mouseDelta[0] * sensitivity[0],
            rotation[1] + mouseDelta[1] * sensitivity[1],
            rotation[2]])
    }

    function dragEnded(d) {
        d3.select(this).attr("fill", "white");
        rotation[0] += mouseDelta[0] * sensitivity[0];
        rotation[1] += mouseDelta[1] * sensitivity[1];
    }

    // ----------========== Things to do on a plot update ==========----------

    function updatePlot(svg, rotation) {
        // 1. Build up the z buffer
        let z_buffer = [];

        for (let i = 0; i < points.length; i++) {
            z_buffer.push({
                type: 'circle',
                group: 'points',
                xyz: points[i]
            })
        }
        for (let poly_idx = 0; poly_idx < polygons.length; poly_idx++) {
            for (let draw_idx = 0; draw_idx < polygons[poly_idx].length; draw_idx++) {
                z_buffer.push({
                    type: 'poly',
                    group: 'scale',
                    poly_index: poly_idx,
                    draw_index: draw_idx,
                    xyz: polygons[poly_idx][draw_idx]
                })
            }
        }
        // 2. Extract the coords from the z-buffer and do the transformations on them
        let projected = math.multiply(
            z_buffer.map(d => {
                return d.xyz;
            }),
            rotZ(rotation[0]),
            rotX(rotation[1]),
            projection
        );
        // 3. Add the transformed coords back into the z-buffer
        z_buffer.forEach((d, i) => {
            d.projected = projected[i];
            d.x = d.projected[0];
            d.y = d.projected[1];
            d.z = d.projected[2];
            return d;
        });

        // 4. Sort the z-buffer
        z_buffer.sort((a, b) => a.projected[2] < b.projected[2] ? -1 : 1);


        // TODO finish pushing the z-buffer through the rest of the pipeline.

        let colorScale = d3.scaleSequential()
            .domain(d3.extent(z_buffer, (d) => d.xyz[2]))
            .interpolator(d3.interpolateViridis);

        if (draw_paths) {
            let num_rows = Math.ceil((stop - start) / step + 1);
            let num_cols = Math.ceil((stop - start) / step + 1);
            let lines = [];
            for (let i = 0; i < num_rows + num_cols; i++) {
                lines.push([]);
            }
            for (let i = 0; i < locs.length; i++) {
                let r = i % num_rows;
                let c = Math.floor(i / num_cols);
                lines[c].push({
                    x: locs[i][0],
                    y: locs[i][1],
                    z: points[i][2],
                    depth: locs[i][2]
                });
                lines[num_rows + r].push({
                    x: locs[i][0],
                    y: locs[i][1],
                    z: points[i][2],
                    depth: locs[i][2]
                })
            }

            let paths = svg.select('.lines').selectAll('path').data(lines);
            paths.enter()
                .append('svg:path')
                .style('fill', 'none')
                .style('stroke-width', 1)
                .style('stroke', 'lightgrey')
                .merge(paths)
                .attr('d', d => lineGen(d));

            paths.exit().remove();
        }


        let buffer = [];
        // Remove the old groups, they can't be re-used.
        svg.select('.points').selectAll('g').remove();
        svg.select('.scale').selectAll('g').remove();
        for (let i = 0; i < z_buffer.length; i++) {
            if ((buffer.length > 0 && z_buffer[i].type !== buffer[buffer.length - 1].type) || i === z_buffer.length - 1) {
                if (buffer[0].type === 'circle') {
                    // Join
                    let circles = svg.select('.points').append('g').selectAll('circle').data(buffer);
                    // Enter
                    circles.enter()
                        .append('circle')
                        .style('stroke', 'white')
                        .style('strokeWeight', 1)
                        .attr('r', scale * 6)
                        .merge(circles)
                        .attr('cx', (d) => xScale(d.x))
                        .attr('cy', (d) => yScale(d.y))
                        // .attr('r', (d) => scale * (6 + 2 * (d.depth - min_r) / (max_r - min_r)))
                        .style("fill", (d) => colorScale(d.xyz[2]));
                    // Exit
                    circles.exit().remove();

                } else if (buffer[0].type === 'poly') {
                    // TODO doesn't take into account one poly with vertices at different z-depths !!!
                    let data = [];
                    let number_of_polys = d3.max(buffer, (d) => d.poly_index);
                    for (let k = 0; k <= number_of_polys; k++) {
                        data.push([]);
                    }
                    for (let j = 0; j < buffer.length; j++) {
                        data[buffer[j].poly_index].push(buffer[j]);
                    }
                    console.log(data);
                    console.log("----");
                    // TODO now that every polygon is in data, they still need to be ordered properly
                    let polygons = svg.select('.scale').append('g').selectAll('polygon').data(data);
                    polygons.enter().append("polygon")
                        .attr("stroke", "black")
                        .attr("fill", "rgba(0,234,255,0.47)")
                        .attr("stroke-width", 1)
                        .merge(polygons)
                        .attr("points", d => d.map(d => [xScale(d.x), yScale(d.y)].join(",")).join(" "));
                    polygons.exit().remove();
                }
                buffer = []
            }
            buffer.push(z_buffer[i])
        }

        // // Join
        // let circles = svg.select('.points').selectAll('circle').data(point_data);
        // // Enter
        // circles.enter()
        //     .append('circle')
        //     .style('stroke', 'white')
        //     .style('strokeWeight', 1)
        //     .merge(circles)
        //     .attr('cx', (d) => xScale(d.x))
        //     .attr('cy', (d) => yScale(d.y))
        //     .attr('r', (d) => scale * (6 + 2 * (d.depth - min_r) / (max_r - min_r)))
        //     .style("fill", (d) => colorScale(d.z));
        // // Exit
        // circles.exit().remove();
        //
        //
        // // console.log(poly_data.map((d) => d.map(d => [xScale(d.x), yScale(d.y)].join(","))));
        // let grid = svg.select('.scale').selectAll('polygon').data(poly_data);
        // grid.enter().append("polygon")
        //     .attr("stroke", "black")
        //     .attr("fill", "none")
        //     .attr("stroke-width", 1)
        //     .merge(grid)
        //     .attr("points", d => d.map(d => [xScale(d.x), yScale(d.y)].join(",")).join(" "));
        // grid.exit().remove();
    }

    updatePlot(svg, rotation)


</script>
</body>